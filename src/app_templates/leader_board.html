<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaderboard</title>
</head>
<body>
    <div class="banner {{ 'warning-banner' if warning_message else '' }}">
        {{ warning_message if warning_message else " " }}
    </div>
    
    <!-- Navigation links at the top of the page -->
    <hr>
    <a href="/leader_board.html">Leader Board</a> |
    <a href="/individual_scores.html">Individual Scores</a> |
    <a href="/player_names.html">Player Names</a> |
    <a href="/admin.html">Admin</a>
    <hr>

    <div class="header-container">
        <svg id="logo"></svg>
        <div class="titles">
            <h1 class="title">Warped Pinball : SYS11.Wifi</h1>
            <h2 class="subtitle" id="game-name">Loading...</h2>
            <h1>Leader Board</h1>
        </div>
    </div>

    <table id="leaderboardTable">
        <thead>
            <tr>
                <th>Rank</th>
                <th>Initials</th>
                <th>Score</th>
                <th>Player Full Name</th>
                <th>Date</th>
            </tr>
        </thead>
        <tbody>
            <!-- Entries will be generated by JavaScript -->
        </tbody>
    </table>

    <script>
          function updateLeaderboard() {
            const TOTAL_ROWS = 20;  // Desired number of rows in the leaderboard
            const tableBody = document.getElementById('leaderboardTable').getElementsByTagName('tbody')[0];

            // Fetch the leaderboard data
            fetch('/leaderboard')
                .then(response => response.json())
                .then(data => {
                    tableBody.innerHTML = '';
                    let count = data.length;
                    data.forEach((player, index) => {
                        let row = tableBody.insertRow();
                        let cellRank = row.insertCell(0);
                        let cellInitials = row.insertCell(1);
                        let cellScore = row.insertCell(2);
                        let cellName = row.insertCell(3);
                        let cellDate = row.insertCell(4);

                        cellRank.innerHTML = index + 1;
                        cellInitials.innerHTML = player.initials;
                        cellScore.innerHTML = player.score.toLocaleString();
                        cellName.innerHTML = player.full_name;
                        cellDate.innerHTML = player.date;
                    });

                    // If fetched data is less than TOTAL_ROWS, fill in the rest with empty cells
                    for (let i = count; i < TOTAL_ROWS; i++) {
                        let row = tableBody.insertRow();
                        let cellRank = row.insertCell(0);
                        let cellInitials = row.insertCell(1);
                        let cellScore = row.insertCell(2);
                        let cellName = row.insertCell(3);
                        let cellDate = row.insertCell(4);

                        cellRank.innerHTML = i + 1;
                        cellInitials.innerHTML = "";
                        cellScore.innerHTML = "";
                        cellName.innerHTML = "";
                        cellDate.innerHTML = "";
                    }
                })
                .catch(error => {
                    console.error('Failed to load leaderboard data:', error);
                    // Fill all rows with empty cells if an error occurs or data fetch fails
                    for (let i = 0; i < TOTAL_ROWS; i++) {
                        let row = tableBody.insertRow();
                        let cellRank = row.insertCell(0);
                        let cellInitials = row.insertCell(1);
                        let cellScore = row.insertCell(2);
                        let cellName = row.insertCell(3);
                        let cellDate = row.insertCell(4);

                        cellRank.innerHTML = i + 1;
                        cellInitials.innerHTML = "";
                        cellScore.innerHTML = "";
                        cellName.innerHTML = "";
                        cellDate.innerHTML = "";
                    }
                });
        }



        window.onload = function() {          
            // Fetch the game name
            fetch('/GameName')
                .then(response => response.json())
                .then(data => {
                    const gameName = data.gamename;  // Access the "gamename" key in the JSON response
                    document.getElementById('game-name').textContent = gameName;
                    document.title = gameName;
                })
                .catch(error => console.error('Failed to load game name:', error));

            updateLeaderboard();
            setInterval(updateLeaderboard, 60000);            
        };
    </script>

    <hr>
    <button id="StartTournamentMode" aria-label="tournament Mode">Start Tournament Mode</button>
    <hr>
    
    <script>
        document.getElementById('StartTournamentMode').onclick = async function() {
            await fetch('/tournamentMode');
            location.reload();  // Reload the page after the fetch is complete
        };
    </script>

    <hr>
    <a href="/leader_board.html">Leader Board</a> |
    <a href="/individual_scores.html">Individual Scores</a> |
    <a href="/player_names.html">Player Names</a> |
    <a href="/admin.html">Admin</a>
    <hr>
<script>
async function clearCache() {
    localStorage.clear();
    location.reload();
}

async function loadAndCacheResource(url, type) {
    const cacheKey = url;
    const cacheTimeKey = `${cacheKey}_time`;
    const cacheTTL = 86400 * 1000; // 24 hours in milliseconds
    const currentTime = Date.now();
    let cachedData = localStorage.getItem(cacheKey);
    let cachedTime = localStorage.getItem(cacheTimeKey);

    // Step 1: Check cache validity
    if (!cachedData || !cachedTime || (currentTime - cachedTime >= cacheTTL)) {
        console.log(`Fetching and caching ${type} resource`);

        try {
            // Step 2: Fetch the gzipped resource
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
            }

            // Step 3: Decompress the gzip stream
            const decompressedStream = response.body.pipeThrough(new DecompressionStream("gzip"));
            cachedData = await new Response(decompressedStream).text();

            // Step 4: Cache decompressed data with timestamp
            localStorage.setItem(cacheKey, cachedData);
            localStorage.setItem(cacheTimeKey, currentTime.toString());

        } catch (error) {
            console.error(`Error fetching or caching ${type} resource:`, error);
            return null;
        }
    } else {
        console.log(`Using cached ${type} resource`);
    }

    // Step 5: Generate and return the DOM element based on the resource type
    return createDOMElement(type, cachedData);
}

// Helper function to create a DOM element based on type and content
function createDOMElement(type, data) {
    let element;
    switch (type) {
        case "css":
            element = document.createElement("style");
            element.textContent = data;
            break;
        case "script":
            element = document.createElement("script");
            element.textContent = data;
            break;
        case "image":
            element = document.createElement("img");
            element.src = URL.createObjectURL(new Blob([data], { type: "image/png" }));
            break;
        case "svg":
            element = new DOMParser().parseFromString(data, "image/svg+xml").documentElement;
            break;
        default:
            console.error(`Unsupported resource type: ${type}`);
            return null;
    }
    return element;
}

// Usage example:
// Insert the returned DOM element wherever you need it on the page
(async () => {
    const cssElement = await loadAndCacheResource("/css/pico.min.css.gz", "css");
    if (cssElement) document.head.appendChild(cssElement);

    const svgElement = await loadAndCacheResource("/svg/logo.svg.gz", "svg");
    if (svgElement) document.getElementById("logo").replaceWith(svgElement);
})();

</script>
</body>
</html>
