<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style id="custom_styles"></style>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
    <link rel="manifest" href="/manifest.json">
</head>
<body>
    <header class="container">
        <nav class="grid">
            <ul>
                <li><a href="#" id="navigate-leader-board">Leader Board</a></li>
                <li><a href="#" id="navigate-about">About Us</a></li>
            </ul>
        </nav>
    </header>

    <main id="content" class="container" aria-busy="true">
    </main>

    <footer class="container">
        <div id="logo" aria-busy="true"></div>
    </footer>

    <script>
        async function loadResource(url, type, targetId) {
            const cacheKey = url;
            const cacheTimeKey = `${cacheKey}_time`;
            // const cacheTTL = 86400 * 1000; // 24 hours in milliseconds
            const cacheTTL = 60 * 1000; // 1 minute in milliseconds
            const currentTime = Date.now();
            let cachedData = localStorage.getItem(cacheKey);
            let cachedTime = localStorage.getItem(cacheTimeKey);

            // Step 1: Check cache validity
            if (!cachedData || !cachedTime || (currentTime - cachedTime >= cacheTTL)) {
                console.log(`Fetching and caching ${type} resource`);

                try {
                    // Step 2: Fetch the resource
                    const response = await fetch(url);

                    if (!response.ok) {
                        throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
                    } else {
                        console.log(`Fetched ${type} resource at ${url}`);
                    }

                    if (url.endsWith('.gz')) {
                        // Step 3: Decompress the gzip stream if the URL ends with .gz
                        const decompressedStream = response.body.pipeThrough(new DecompressionStream("gzip"));
                        cachedData = await new Response(decompressedStream).text();
                    } else {
                        cachedData = await response.text();
                    }

                    // Step 4: Cache decompressed data with timestamp
                    localStorage.setItem(cacheKey, cachedData);
                    localStorage.setItem(cacheTimeKey, currentTime.toString());

                } catch (error) {
                    console.error(`Error fetching or caching ${type} resource:`, error);
                    return;
                }
            } else {
                console.log(`Using cached ${type} resource`);
            }

            // Step 5: Generate and replace the target element with the new DOM element
            replaceDOMElement(targetId, type, cachedData);
        }

        // Helper function to create and replace a DOM element based on type and content
        function replaceDOMElement(targetId, type, data) {
            let newElement;
            switch (type) {
                case "css":
                    newElement = document.createElement("style");
                    newElement.textContent = data;
                    newElement.id = targetId;
                    break;
                case "js":
                    newElement = document.createElement("script");
                    newElement.textContent = data;
                    newElement.id = targetId;
                    break;
                case "image":
                    newElement = document.createElement("img");
                    newElement.src = URL.createObjectURL(new Blob([data], { type: "image/png" }));
                    newElement.id = targetId;
                    break;
                case "svg":
                    newElement = new DOMParser().parseFromString(data, "image/svg+xml").documentElement;
                    newElement.id = targetId;
                    break;
                case "html":
                    newElement = document.createElement("div");
                    newElement.innerHTML = data;
                    newElement.id = targetId;
                    break;
                default:
                    console.error(`Unsupported resource type: ${type}`);
                    return;
            }

            // Replace the target element with the new element
            const targetElement = document.getElementById(targetId);
            if (targetElement && newElement) {
                // Special handling for SVG - ensure appending as a child element
                if (type === "svg") {
                    targetElement.innerHTML = "";
                    targetElement.appendChild(newElement);
                } else {
                    targetElement.replaceWith(newElement);
                }
            } else {
                console.error(`Target element with ID '${targetId}' not found or invalid new element.`);
            }
        }

        async function clearCache() {
            localStorage.clear();
            location.reload();
        }
        
        (async () => {
            await loadResource("/css/pico.min.css.gz", "css", "custom_styles");
            await loadResource("/svg/logo.svg.gz", "svg", "logo");
            await loadResource("/js/main.js.gz", "js", "main_script");
        })();
    </script>
    <div id="main_script"></div>
    <div id="custom_script"></div>
</body>
</html>
