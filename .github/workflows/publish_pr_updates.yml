name: Publish PR dev updates

on:
  workflow_run:
    workflows: ["Build and Deploy"]
    types:
      - completed

jobs:
  publish:
    # Only care about successful PR builds
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest

    permissions:
      contents: write        # we want to push to a branch
      pull-requests: write   # we want to comment on the PR

    steps:
      - name: Download PR update artifacts
        uses: actions/download-artifact@65462800fd760344b1a7b4382951275a0abb4808 # v4.3.3
        with:
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          name: update-files
          path: pr-artifacts

      - name: Check out default branch
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Publish raw update files
        id: publish_raw_updates
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const fs = require('fs/promises');
            const path = require('path');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const defaultBranch = context.payload.repository.default_branch;
            const branch = 'pr-update-artifacts';

            // Get PR number from the triggering workflow_run payload
            const pr = context.payload.workflow_run.pull_requests[0];
            const prNumber = pr.number;

            const basePath = `pr-artifacts/pr-${prNumber}`;

            async function listFiles(dir) {
              const entries = await fs.readdir(dir, { withFileTypes: true });
              const out = [];
              for (const entry of entries) {
                const full = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  out.push(...await listFiles(full));
                } else {
                  out.push(full);
                }
              }
              return out;
            }

            const artifactRoot = path.join(process.cwd(), 'pr-artifacts');
            // Check if artifactRoot exists
            try {
              await fs.access(artifactRoot);
            } catch {
               console.log('No pr-artifacts directory found. Skipping.');
               return;
            }

            const allFiles = await listFiles(artifactRoot);
            const files = allFiles.map(f => ({
              source: f,
              filename: path.relative(artifactRoot, f),
              label: path.relative(artifactRoot, f),
            }));

            const committer = {
              name: 'github-actions[bot]',
              email: '41898282+github-actions[bot]@users.noreply.github.com',
            };

            async function ensureBranch() {
              try {
                await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
              } catch (error) {
                if (error.status !== 404) throw error;

                const { data: defaultRef } = await github.rest.git.getRef({
                  owner,
                  repo,
                  ref: `heads/${defaultBranch}`,
                });

                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: `refs/heads/${branch}`,
                  sha: defaultRef.object.sha,
                });
              }
            }

            await ensureBranch();

            const { data: branchRef } = await github.rest.git.getRef({
              owner,
              repo,
              ref: `heads/${branch}`,
            });

            const { data: branchCommit } = await github.rest.git.getCommit({
              owner,
              repo,
              commit_sha: branchRef.object.sha,
            });

            const treeEntries = [];
            const links = [];

            for (const file of files) {
              let contents;
              try {
                contents = await fs.readFile(file.source, 'utf8');
              } catch (error) {
                if (error.code === 'ENOENT') {
                  core.warning(`Skipping ${file.source} because it was not found.`);
                  continue;
                }
                throw error;
              }

              const repoPath = `${basePath}/${file.filename}`;
              treeEntries.push({
                path: repoPath,
                mode: '100644',
                type: 'blob',
                content: contents,
              });

              links.push({
                name: file.label,
                url: `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${repoPath}`,
              });
            }

            if (treeEntries.length > 0) {
              const { data: tree } = await github.rest.git.createTree({
                owner,
                repo,
                base_tree: branchCommit.tree.sha,
                tree: treeEntries,
              });

              const commitMessage = `Publish ${basePath} for PR ${prNumber}`;

              const { data: commit } = await github.rest.git.createCommit({
                owner,
                repo,
                message: commitMessage,
                tree: tree.sha,
                parents: [branchCommit.sha],
                committer,
                author: committer,
              });

              await github.rest.git.updateRef({
                owner,
                repo,
                ref: `heads/${branch}`,
                sha: commit.sha,
                force: true,
              });
            }

            core.setOutput('links', JSON.stringify(links));

      - name: Comment with update artifact links
        if: ${{ steps.publish_raw_updates.outputs.links != '' }}
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.workflow_run.pull_requests[0];
            const issue_number = pr.number;
            const marker = '<!-- pr-update-artifacts -->';

            let rawLinks = [];
            try {
              rawLinks = JSON.parse(`${{ steps.publish_raw_updates.outputs.links }}` || '[]');
            } catch (error) {
              core.warning('Failed to parse raw links JSON.');
            }

            if (rawLinks.length === 0) {
              console.log('No raw artifact links available to publish.');
              return;
            }

            const bodyLines = [marker, '', 'Developer build links:'];

            for (const link of rawLinks) {
              bodyLines.push(`**${link.name}**`);
              bodyLines.push('```text');
              bodyLines.push(link.url);
              bodyLines.push('```');
              bodyLines.push('');
            }

            if (bodyLines[bodyLines.length - 1] === '') {
              bodyLines.pop();
            }

            const body = bodyLines.join('\n');

            const comments = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number },
            );

            const existingComment = comments.find(
              comment => typeof comment.body === 'string' && comment.body.includes(marker),
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existingComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body,
              });
            }
